<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Neotoma Mammal Visualization</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">    
        <link rel="stylesheet" href="index.css">
    </head>
    <body>
        <div id="layout" style="display:flex; align-items:flex-start; gap:16px;">
            <div id="stage" style="position:relative;">
                <div id="chart"></div>
                <div id="popup" style="position:absolute; left:-9999px; top:-9999px; background:#fff; border:1px solid #ddd; box-shadow:0 4px 12px rgba(0,0,0,0.15); border-radius:6px; padding:10px 12px; max-width:320px; z-index:1000;"></div>
            </div>
            <div id="right-panel" style="min-width:360px; display:flex; flex-direction:column; gap:16px;">
                <div id="title-section">
                    <h1>Neotoma Taxonomy Hierarchical Visualizer</h1>
                </div>
                <div id="sidebar">
                <div id="controls">
                    <!-- First row: Rotate and Zoom -->
                    <div class="control-row rotate-zoom-row">
                        <div class="rotate-control">
                            <label for="rotate">Rotate:</label>
                            <input id="rotate" type="range" min="-180" max="180" value="0" step="1">
                            <span id="rotateValue">0°</span>
                        </div>
                        <div class="zoom-control">
                            <button id="zoomOut">-</button>
                            <button id="zoomIn">+</button>
                            <button id="zoomReset">reset</button>
                            <span id="zoomValue">1.0×</span>
                            <div id="viewSwitchGroup" class="view-switch-group">
                                <button id="wholeViewBtn" class="view-switch-btn active">Whole View</button>
                                <button id="focusViewBtn" class="view-switch-btn">Focus View</button>
                            </div>
                        </div>
                    </div>

                    <!-- Second row: Taxon Group and Search -->
                    <div class="control-row taxon-group-search-row">
                        <div class="taxon-group-section">
                            <label for="taxagroupSelect">Taxon Group:</label>
                            <div class="custom-select-wrapper">
                                <select id="taxagroupSelect" style="display: none;">
                                    <option value="">Loading...</option>
                                </select>
                                <div class="custom-select">
                                    <div class="custom-select-trigger">Loading...</div>
                                    <div class="custom-options"></div>
                                </div>
                            </div>
                        </div>
                        <div class="search-section">
                            <input id="searchInput" type="text" placeholder="Search name or id">
                            <button id="searchBtn">Search</button>
                        </div>
                    </div>
                </div>
                <div id="info"></div>
                <div id="treeViewToggle" style="margin-top: 12px; display: block; visibility: visible;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 14px; font-weight: 500;">Tree View:</label>
                        <button id="mainTreeBtn" class="tree-view-btn active" style="
                            padding: 6px 12px;
                            background: linear-gradient(135deg, #43a047, #43a047);
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 600;
                            font-family: 'DM Sans', sans-serif;
                            transition: all 0.2s ease;
                        ">Main Tree</button>
                        <button id="orphanTreeBtn" class="tree-view-btn" style="
                            padding: 6px 12px;
                            background: #e5e7eb;
                            color: #374151;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 600;
                            font-family: 'DM Sans', sans-serif;
                            transition: all 0.2s ease;
                        ">Orphan Nodes</button>
                    </div>
                </div>
                <div id="navigation" style="margin-top: 12px; display: none;">
                    <button id="backButton" style="
                        padding: 8px 16px;
                        background: linear-gradient(135deg, #43a047, #43a047);
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 600;
                        font-family: 'DM Sans', sans-serif;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.filter='brightness(1.1)'" onmouseout="this.style.filter='brightness(1)'">
                        ← Go Back
                    </button>
                </div>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
        <script src="src/taxon-group-select.js"></script>
        <script type="module" src="mammal_path_combined.js"></script>
        <script type="module">
        import { initViewSwitch, resetViewState } from './src/viewSwitch.js';
        // Convert data/taxonpaths.json format to the format expected by renderMammalTree
        function convertTaxonPaths(data) {
            // data is an object with a SQL query string as key and array as value
            const rows = Object.values(data)[0] || [];
            return rows.map(row => {
                // Convert array_to_string (comma-separated IDs) to array
                const ids_root_to_leaf = row.array_to_string 
                    ? row.array_to_string.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id))
                    : [];
                // Convert taxonnames (comma-separated names) to array
                const names_root_to_leaf = row.taxonnames 
                    ? row.taxonnames.split(',').map(name => name.trim())
                    : [];
                return {
                    taxonid: row.taxonid,
                    taxonname: row.taxonname,
                    ids_root_to_leaf: ids_root_to_leaf,
                    names_root_to_leaf: names_root_to_leaf,
                    taxagroupid: row.taxagroupid
                };
            });
        }

        // Extract unique taxagroupid values
        function extractTaxaGroups(rows) {
            const groups = new Set();
            rows.forEach(row => {
                if (row.taxagroupid) {
                    groups.add(row.taxagroupid);
                }
            });
            return Array.from(groups).sort();
        }

        // Filter rows by taxagroupid and find appropriate root
        function filterRowsByGroup(rows, taxagroupid) {
            if (!taxagroupid) return [];
            const filtered = rows.filter(row => row.taxagroupid === taxagroupid);
            
            if (taxagroupid === 'MAM') {
                // For Mammalia, filter to only include paths that contain Mammalia (6171)
                // and extract paths starting from Mammalia
                return filtered
                    .filter(row => row.ids_root_to_leaf.includes(6171))
                    .map(row => {
                        const mammaliaIndex = row.ids_root_to_leaf.indexOf(6171);
                        return {
                            ...row,
                            ids_root_to_leaf: row.ids_root_to_leaf.slice(mammaliaIndex),
                            names_root_to_leaf: row.names_root_to_leaf.slice(mammaliaIndex)
                        };
                    });
            } else {
                // For other groups, find the most common root node
                // Count occurrences of first node in each path
                const rootCounts = new Map();
                filtered.forEach(row => {
                    if (row.ids_root_to_leaf.length > 0) {
                        const rootId = row.ids_root_to_leaf[0];
                        rootCounts.set(rootId, (rootCounts.get(rootId) || 0) + 1);
                    }
                });
                
                // Find the most common root
                let mostCommonRoot = 32182; // Default to Eukaryota
                let maxCount = 0;
                rootCounts.forEach((count, rootId) => {
                    if (count > maxCount) {
                        maxCount = count;
                        mostCommonRoot = rootId;
                    }
                });
                
                // Filter to only include paths starting from the most common root
                return filtered.filter(row => 
                    row.ids_root_to_leaf.length > 0 && 
                    row.ids_root_to_leaf[0] === mostCommonRoot
                );
            }
        }
        
        // Get root info for a taxagroupid
        function getRootInfo(rows, taxagroupid) {
            if (taxagroupid === 'MAM') {
                return { rootId: 6171, rootName: 'Mammalia' };
            }
            
            // For other groups, find the most common root
            const filtered = rows.filter(row => row.taxagroupid === taxagroupid);
            const rootCounts = new Map();
            const rootNames = new Map();
            
            filtered.forEach(row => {
                if (row.ids_root_to_leaf.length > 0) {
                    const rootId = row.ids_root_to_leaf[0];
                    const rootName = row.names_root_to_leaf[0];
                    rootCounts.set(rootId, (rootCounts.get(rootId) || 0) + 1);
                    if (!rootNames.has(rootId)) {
                        rootNames.set(rootId, rootName);
                    }
                }
            });
            
            let mostCommonRoot = 32182; // Default to Eukaryota
            let maxCount = 0;
            rootCounts.forEach((count, rootId) => {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommonRoot = rootId;
                }
            });
            
            return {
                rootId: mostCommonRoot,
                rootName: rootNames.get(mostCommonRoot) || 'Root'
            };
        }

        let allRows = [];
        let currentTaxagroupid = null; // Start with null for initial view
        let navigationStack = []; // Stack to track navigation history
        let isInitialView = true; // Track if we're in the initial 4-level view
        let isSyncingDropdown = false; // Flag to prevent recursive calls when syncing dropdown
        let taxagroupNames = {}; // Store taxagroupid to full name mapping

        // Load both taxonpaths and taxagroup names mapping in parallel
        Promise.all([
            fetch("data/taxonpaths.json").then(r => r.json()),
            fetch("data/taxagroup_names.json").then(r => r.json()).catch(() => ({})) // Fallback to empty object if file not found
        ])
            .then(([taxonData, namesMap]) => {
                taxagroupNames = namesMap; // Store the mapping
                allRows = convertTaxonPaths(taxonData);
                
                // Extract unique taxagroupid values
                const taxaGroups = extractTaxaGroups(allRows);
                
                // Populate dropdown
                const select = document.getElementById('taxagroupSelect');
                select.innerHTML = '';
                
                // Add "Major Groups" as the first option
                const majorGroupsOption = document.createElement('option');
                majorGroupsOption.value = '';
                majorGroupsOption.textContent = 'Major Groups';
                select.appendChild(majorGroupsOption);
                
                // Add all other taxon groups with full names
                taxaGroups.forEach(group => {
                    const option = document.createElement('option');
                    option.value = group; // Keep taxagroupid as value
                    // Use full name from mapping, fallback to taxagroupid if not found
                    option.textContent = taxagroupNames[group] || group;
                    select.appendChild(option);
                });
                
                // Set "Major Groups" as selected (initial view)
                select.value = '';
                
                // Load initial 4-level view
                loadInitialView();
                
                // Handle dropdown change
                select.addEventListener('change', (e) => {
                    // Skip if we're programmatically syncing the dropdown
                    if (isSyncingDropdown) {
                        return;
                    }
                    
                    const selectedValue = e.target.value;
                    
                    if (selectedValue === '') {
                        // "Major Groups" selected - show initial view
                        currentTaxagroupid = null;
                        isInitialView = true;
                        navigationStack = [];
                        currentTreeType = 'main';
                        
                        // Show tree toggle for Major Groups view
                        const toggleDiv = document.getElementById('treeViewToggle');
                        if (toggleDiv) {
                            toggleDiv.style.display = 'block';
                            toggleDiv.style.visibility = 'visible';
                        }
                        
                        updateBackButton();
                        loadInitialView();
                    } else {
                        // Specific taxon group selected
                        currentTaxagroupid = selectedValue;
                        isInitialView = false;
                        navigationStack = [];
                        currentTreeType = 'main';
                        
                        // Hide tree toggle when selecting a specific group
                        const toggleDiv = document.getElementById('treeViewToggle');
                        if (toggleDiv) {
                            toggleDiv.style.display = 'none';
                        }
                        
                        updateBackButton();
                        loadTreeForGroup(currentTaxagroupid);
                    }
                });
            })
            .catch(err => console.error('Failed to load data files', err));

        // Build initial 4-level view (Eukaryota, Animalia, Vertebrata, Mammalia)
        // Returns both main tree and orphan tree
        function buildInitialView() {
            // Build first 4 levels for ALL data (not grouped by taxagroupid)
            const levelMap = new Map(); // Map of level -> Map of id -> nodeData
            const idToTaxagroupid = new Map(); // Track taxagroupid for each node ID
            const standaloneOrphans = []; // Nodes with only one ID (no hierarchical path)
            
            allRows.forEach(row => {
                const ids = row.ids_root_to_leaf || [];
                const names = row.names_root_to_leaf || [];
                const taxagroupid = row.taxagroupid;
                
                // Check for standalone orphan nodes (only one ID, no path)
                if (ids.length === 1 && names.length === 1) {
                    standaloneOrphans.push({
                        id: ids[0],
                        name: names[0],
                        taxagroupid: taxagroupid || 'MAM',
                        taxonid: row.taxonid,
                        taxonname: row.taxonname
                    });
                    return; // Skip processing for standalone orphans
                }
                
                // Only process rows with at least 4 levels
                if (ids.length >= 4 && names.length >= 4) {
                    // Get first 4 levels
                    for (let i = 0; i < Math.min(4, ids.length); i++) {
                        const id = ids[i];
                        const name = names[i];
                        
                        if (!levelMap.has(i)) {
                            levelMap.set(i, new Map());
                        }
                        
                        const levelData = levelMap.get(i);
                        if (!levelData.has(id)) {
                            levelData.set(id, {
                                id: id,
                                name: name,
                                taxagroupids: new Set(), // Track all taxagroupids for this node
                                children: new Set(),
                                pathCount: 0 // Count how many paths go through this node
                            });
                        }
                        
                        // Track taxagroupid
                        if (taxagroupid) {
                            levelData.get(id).taxagroupids.add(taxagroupid);
                            idToTaxagroupid.set(id, taxagroupid); // Store most recent taxagroupid
                        }
                        
                        // Increment path count
                        levelData.get(id).pathCount++;
                        
                        // Add child relationship
                        if (i > 0) {
                            const parentId = ids[i - 1];
                            const parentData = levelMap.get(i - 1);
                            if (parentData && parentData.has(parentId)) {
                                parentData.get(parentId).children.add(id);
                            }
                        }
                    }
                }
            });
            
            // Convert to tree structure starting from level 0 (Eukaryota)
            const rootNodes = [];
            const orphanNodes = []; // Nodes with only one taxonname that aren't linking to anything
            const rootLevel = levelMap.get(0);
            
            if (rootLevel) {
                rootLevel.forEach((nodeData, id) => {
                    // Use the most common taxagroupid for this node
                    const taxagroupids = Array.from(nodeData.taxagroupids);
                    const taxagroupid = taxagroupids[0] || 'MAM'; // Use first one as default
                    
                    // Recursively build children up to level 3 (Mammalia)
                    function buildChildren(parentNode, level, isOrphan = false) {
                        if (level >= 3) return; // Stop at level 3 (Mammalia)
                        
                        const nextLevel = levelMap.get(level + 1);
                        if (!nextLevel) return;
                        
                        parentNode.children = [];
                        const parentData = levelMap.get(level).get(parentNode.id);
                        const childrenSet = parentData?.children || new Set();
                        
                        childrenSet.forEach(childId => {
                            const childData = nextLevel.get(childId);
                            
                            // Check if this is an orphan node (single taxonname, no children)
                            // An orphan node: appears in only one path AND has no children
                            const isOrphanNode = childData && 
                                childData.pathCount === 1 && 
                                childData.children.size === 0;
                            
                            // For main tree: include if has children, is level 2, or has multiple paths
                            // For orphan tree: include only orphan nodes
                            const shouldInclude = isOrphan 
                                ? isOrphanNode
                                : (childData && 
                                    (childData.children.size > 0 || level === 2 || childData.pathCount > 1));
                            
                            if (childData && shouldInclude) {
                                // Use the most common taxagroupid for this child
                                const childTaxagroupids = Array.from(childData.taxagroupids);
                                const childTaxagroupid = childTaxagroupids[0] || idToTaxagroupid.get(childId) || 'MAM';
                                
                                const childNode = {
                                    id: childId,
                                    name: childData.name,
                                    taxagroupid: childTaxagroupid,
                                    children: []
                                };
                                buildChildren(childNode, level + 1, isOrphan);
                                parentNode.children.push(childNode);
                            }
                        });
                        
                        // Remove children property if empty
                        if (parentNode.children.length === 0) {
                            delete parentNode.children;
                        }
                    }
                    
                    // Build main tree node
                    if (nodeData.children.size > 0) {
                        const node = {
                            id: id,
                            name: nodeData.name,
                            taxagroupid: taxagroupid,
                            children: []
                        };
                        buildChildren(node, 0, false);
                        
                        // Only add if node has children after building
                        if (node.children && node.children.length > 0) {
                            rootNodes.push(node);
                        }
                    }
                    
                    // Build orphan tree node (nodes with single taxonname, no children)
                    // Check if this root has orphan descendants at any level
                    function hasOrphanDescendants(nodeId, level) {
                        if (level >= 3) return false;
                        const nodeData = levelMap.get(level)?.get(nodeId);
                        if (!nodeData) return false;
                        
                        // Check if this node itself is an orphan (but only if it's not level 0)
                        if (level > 0 && nodeData.pathCount === 1 && nodeData.children.size === 0) {
                            return true;
                        }
                        
                        // Check descendants
                        for (const childId of nodeData.children) {
                            if (hasOrphanDescendants(childId, level + 1)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    
                    if (hasOrphanDescendants(id, 0)) {
                        const orphanNode = {
                            id: id,
                            name: nodeData.name,
                            taxagroupid: taxagroupid,
                            children: []
                        };
                        buildChildren(orphanNode, 0, true);
                        
                        // Only add if node has orphan children after building
                        if (orphanNode.children && orphanNode.children.length > 0) {
                            orphanNodes.push(orphanNode);
                        }
                    }
                });
            }
            
            // Build orphan tree from standalone orphans
            // Structure: Root -> taxagroupid -> orphan nodes
            const orphanTreeByGroup = new Map();
            let orphanGroupIdCounter = -1000000; // Use negative IDs to avoid conflicts
            
            standaloneOrphans.forEach(orphan => {
                const group = orphan.taxagroupid || 'MAM';
                if (!orphanTreeByGroup.has(group)) {
                    orphanTreeByGroup.set(group, {
                        id: orphanGroupIdCounter--,
                        name: group, // Just the taxagroupid as the name
                        taxagroupid: group,
                        children: []
                    });
                }
                const groupRoot = orphanTreeByGroup.get(group);
                groupRoot.children.push({
                    id: orphan.id,
                    name: orphan.name,
                    taxagroupid: orphan.taxagroupid,
                    children: []
                });
            });
            
            // Add standalone orphans to orphan tree (these will be children of the synthetic root)
            orphanTreeByGroup.forEach((groupRoot, group) => {
                if (groupRoot.children.length > 0) {
                    orphanNodes.push(groupRoot);
                }
            });
            
            console.log('Orphan nodes found:', {
                standaloneOrphans: standaloneOrphans.length,
                orphanTreeNodes: orphanNodes.length,
                sampleOrphans: standaloneOrphans.slice(0, 5)
            });
            
            return { mainTree: rootNodes, orphanTree: orphanNodes };
        }
        
        // Store both trees
        let mainTreeNodes = [];
        let orphanTreeNodes = [];
        let currentTreeType = 'main'; // 'main' or 'orphan'
        
        // Load initial 4-level view
        async function loadInitialView(treeType = 'main') {
            isInitialView = true;
            currentTaxagroupid = null;
            navigationStack = [];
            updateBackButton();
            syncDropdownValue();
            currentTreeType = treeType;
            
            // Build trees if not already built
            if (mainTreeNodes.length === 0 && orphanTreeNodes.length === 0) {
                const trees = buildInitialView();
                mainTreeNodes = trees.mainTree;
                orphanTreeNodes = trees.orphanTree;
                console.log('Built trees:', {
                    mainTreeCount: mainTreeNodes.length,
                    orphanTreeCount: orphanTreeNodes.length,
                    mainTreeSample: mainTreeNodes.slice(0, 2),
                    orphanTreeSample: orphanTreeNodes.slice(0, 2)
                });
            }
            
            // Select which tree to show
            const rootNodes = treeType === 'main' ? mainTreeNodes : orphanTreeNodes;
            
            // Show/hide tree toggle - always show in initial view
            const toggleDiv = document.getElementById('treeViewToggle');
            if (toggleDiv) {
                // Always show the toggle in initial view (user can switch even if one tree is empty)
                toggleDiv.style.display = 'block';
                toggleDiv.style.visibility = 'visible';
                console.log('Toggle visibility set:', {
                    mainTreeNodes: mainTreeNodes.length,
                    orphanTreeNodes: orphanTreeNodes.length,
                    toggleDivDisplay: toggleDiv.style.display,
                    toggleDivVisibility: toggleDiv.style.visibility,
                    toggleDivExists: !!toggleDiv,
                    toggleDivOffsetHeight: toggleDiv.offsetHeight
                });
            } else {
                console.error('treeViewToggle element not found in DOM!');
            }
            updateTreeToggleButtons();
            
            // Convert to rows format for rendering
            const rows = [];
            rootNodes.forEach(root => {
                function traverse(node, pathIds = [], pathNames = []) {
                    const newPathIds = [...pathIds, node.id];
                    const newPathNames = [...pathNames, node.name];
                    
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => {
                            traverse(child, newPathIds, newPathNames);
                        });
                    } else {
                        // Leaf node - create a row
                        rows.push({
                            taxonid: node.id,
                            taxonname: node.name,
                            ids_root_to_leaf: newPathIds,
                            names_root_to_leaf: newPathNames,
                            taxagroupid: node.taxagroupid
                        });
                    }
                }
                traverse(root);
            });
            
            // Clear previous chart
            d3.select('#chart').selectAll('*').remove();
            resetViewState();
            
            // Determine root ID and name based on tree type
            let rootId, rootName;
            let nodesToRender = rootNodes;
            
            if (treeType === 'orphan') {
                // For orphan tree, always use a synthetic root
                // Structure will be: Root -> taxagroupid -> orphan nodes
                rootId = -999999;
                rootName = 'Root';
                // The render function will add all rootNodes (taxagroupid nodes) as children of this synthetic root
            } else {
                // For main tree, use synthetic root
                rootId = 0;
                rootName = 'Root';
            }
            
            // Render with special handling for initial view
            await window.renderMammalTree({ 
                rows: rows,
                allRowsForSynonyms: allRows,
                rootId: rootId,
                rootName: rootName,
                isInitialView: true,
                rootNodes: nodesToRender
            });
        }
        
        // Update tree toggle button states
        function updateTreeToggleButtons() {
            const mainBtn = document.getElementById('mainTreeBtn');
            const orphanBtn = document.getElementById('orphanTreeBtn');
            
            if (mainBtn && orphanBtn) {
                if (currentTreeType === 'main') {
                    mainBtn.classList.add('active');
                    mainBtn.style.background = 'linear-gradient(135deg, #43a047, #43a047)';
                    mainBtn.style.color = 'white';
                    orphanBtn.classList.remove('active');
                    orphanBtn.style.background = '#e5e7eb';
                    orphanBtn.style.color = '#374151';
                } else {
                    orphanBtn.classList.add('active');
                    orphanBtn.style.background = 'linear-gradient(135deg, #43a047, #43a047)';
                    orphanBtn.style.color = 'white';
                    mainBtn.classList.remove('active');
                    mainBtn.style.background = '#e5e7eb';
                    mainBtn.style.color = '#374151';
                }
            }
        }
        
        // Set up tree toggle buttons
        function setupTreeToggle() {
            const mainBtn = document.getElementById('mainTreeBtn');
            const orphanBtn = document.getElementById('orphanTreeBtn');
            
            if (mainBtn) {
                mainBtn.addEventListener('click', () => {
                    if (currentTreeType !== 'main') {
                        loadInitialView('main');
                    }
                });
            }
            
            if (orphanBtn) {
                orphanBtn.addEventListener('click', () => {
                    if (currentTreeType !== 'orphan') {
                        loadInitialView('orphan');
                    }
                });
            }
        }
        
        // Set up when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupTreeToggle);
        } else {
            setupTreeToggle();
        }
        
        // Navigate to a specific node (drill down)
        async function navigateToNode(nodeId, nodeName, taxagroupid) {
            // Push current state to navigation stack
            navigationStack.push({
                taxagroupid: currentTaxagroupid,
                isInitialView: isInitialView,
                rootId: currentRootId,
                rootName: currentRootName,
                treeType: currentTreeType
            });
            
            isInitialView = false;
            currentTaxagroupid = taxagroupid;
            currentRootId = nodeId;
            currentRootName = nodeName;
            
            // Hide tree toggle when navigating away from initial view
            const toggleDiv = document.getElementById('treeViewToggle');
            if (toggleDiv) {
                toggleDiv.style.display = 'none';
            }
            
            updateBackButton();
            syncDropdownValue();
            
            // Filter rows to start from this node
            const filteredRows = allRows
                .filter(row => {
                    const ids = row.ids_root_to_leaf || [];
                    return ids.includes(nodeId);
                })
                .map(row => {
                    const ids = row.ids_root_to_leaf || [];
                    const names = row.names_root_to_leaf || [];
                    const index = ids.indexOf(nodeId);
                    
                    if (index >= 0) {
                        return {
                            ...row,
                            ids_root_to_leaf: ids.slice(index),
                            names_root_to_leaf: names.slice(index)
                        };
                    }
                    return row;
                })
                .filter(row => row.ids_root_to_leaf.length > 1); // Must have at least the root and one child
            
            // Get all rows for this taxagroupid for synonyms
            const allRowsForGroup = allRows.filter(row => row.taxagroupid === taxagroupid);
            
            // Clear previous chart
            d3.select('#chart').selectAll('*').remove();
            resetViewState();
            
            // Initialize view switch
            initViewSwitch(
                async (rows, rootId, rootName, allRowsForSynonyms) => {
                    d3.select('#chart').selectAll('*').remove();
                    await window.renderMammalTree({ 
                        rows: rows,
                        allRowsForSynonyms: allRowsForSynonyms,
                        rootId: rootId,
                        rootName: rootName
                    });
                },
                filteredRows,
                { rootId: nodeId, rootName: nodeName },
                taxagroupid,
                allRowsForGroup
            );
            
            // Render tree
            await window.renderMammalTree({ 
                rows: filteredRows,
                allRowsForSynonyms: allRowsForGroup,
                rootId: nodeId,
                rootName: nodeName
            });
        }
        
        // Go back in navigation
        async function goBack() {
            if (navigationStack.length === 0) {
                // Go back to initial view
                await loadInitialView(currentTreeType);
                return;
            }
            
            const previousState = navigationStack.pop();
            currentTaxagroupid = previousState.taxagroupid;
            isInitialView = previousState.isInitialView;
            currentRootId = previousState.rootId;
            currentRootName = previousState.rootName;
            currentTreeType = previousState.treeType || 'main';
            
            updateBackButton();
            syncDropdownValue();
            
            if (isInitialView) {
                await loadInitialView(currentTreeType);
            } else if (currentTaxagroupid) {
                // Hide tree toggle when not in initial view
                const toggleDiv = document.getElementById('treeViewToggle');
                if (toggleDiv) {
                    toggleDiv.style.display = 'none';
                }
                await loadTreeForGroup(currentTaxagroupid);
            }
        }
        
        // Sync dropdown value with current state
        function syncDropdownValue() {
            const select = document.getElementById('taxagroupSelect');
            if (select) {
                let newValue = '';
                if (isInitialView && currentTaxagroupid === null) {
                    // Major Groups view
                    newValue = '';
                } else if (currentTaxagroupid) {
                    // Specific taxon group
                    newValue = currentTaxagroupid;
                } else {
                    // Fallback to Major Groups
                    newValue = '';
                }
                
                // Only update if value has changed to avoid unnecessary events
                if (select.value !== newValue) {
                    isSyncingDropdown = true;
                    select.value = newValue;
                    // Trigger change event to sync custom select
                    const event = new Event('change', { bubbles: true });
                    select.dispatchEvent(event);
                    // Reset flag after a short delay to allow event to process
                    setTimeout(() => {
                        isSyncingDropdown = false;
                    }, 0);
                }
            }
        }
        
        // Update back button visibility
        function updateBackButton() {
            const navDiv = document.getElementById('navigation');
            const backBtn = document.getElementById('backButton');
            
            if (navDiv && backBtn) {
                if (isInitialView && navigationStack.length === 0) {
                    navDiv.style.display = 'none';
                } else {
                    navDiv.style.display = 'block';
                }
            }
        }
        
        // Set up back button (will be called after DOM is ready)
        function setupBackButton() {
            const backBtn = document.getElementById('backButton');
            if (backBtn) {
                // Remove existing listeners
                const newBtn = backBtn.cloneNode(true);
                backBtn.parentNode.replaceChild(newBtn, backBtn);
                newBtn.addEventListener('click', goBack);
            }
        }
        
        // Set up when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupBackButton);
        } else {
            setupBackButton();
        }
        
        let currentRootId = null;
        let currentRootName = null;

        async function loadTreeForGroup(taxagroupid) {
            if (!taxagroupid) {
                // Clear the chart if no group selected
                d3.select('#chart').selectAll('*').remove();
                resetViewState();
                return;
            }
            
            currentTaxagroupid = taxagroupid;
            isInitialView = false;
            syncDropdownValue();
            
            // Hide tree toggle when loading a specific group
            const toggleDiv = document.getElementById('treeViewToggle');
            if (toggleDiv) {
                toggleDiv.style.display = 'none';
            }
            
            // Filter rows by taxagroupid for the tree
            const filteredRows = filterRowsByGroup(allRows, taxagroupid);
            
            if (filteredRows.length === 0) {
                console.warn(`No data found for taxagroupid: ${taxagroupid}`);
                d3.select('#chart').selectAll('*').remove();
                resetViewState();
                return;
            }
            
            // Get ALL rows for this taxagroupid (including those without full paths)
            // This is needed to add missing synonym nodes
            const allRowsForGroup = allRows.filter(row => row.taxagroupid === taxagroupid);
            
            // Get root info for this taxagroupid
            const rootInfo = getRootInfo(allRows, taxagroupid);
            currentRootId = rootInfo.rootId;
            currentRootName = rootInfo.rootName;
            
            // Clear previous chart
            d3.select('#chart').selectAll('*').remove();
            
            // Reset view state when switching groups
            resetViewState();
            
            // Initialize view switch with render function
            initViewSwitch(
                async (rows, rootId, rootName, allRowsForSynonyms) => {
                    d3.select('#chart').selectAll('*').remove();
                    await window.renderMammalTree({ 
                        rows: rows,
                        allRowsForSynonyms: allRowsForSynonyms,
                        rootId: rootId,
                        rootName: rootName
                    });
                },
                filteredRows,
                rootInfo,
                taxagroupid,
                allRowsForGroup
            );
            
            // Render tree with appropriate root (now async to load synonyms)
            // Pass filteredRows for tree building, allRowsForGroup for synonym lookup
            await window.renderMammalTree({ 
                rows: filteredRows,
                allRowsForSynonyms: allRowsForGroup,
                rootId: rootInfo.rootId,
                rootName: rootInfo.rootName
            });
        }
        
        // Export navigateToNode for use in renderMammalTree
        window.navigateToNode = navigateToNode;
        </script>
    </body>
</html>